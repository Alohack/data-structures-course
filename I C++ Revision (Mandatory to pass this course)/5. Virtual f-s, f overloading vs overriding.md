##### 5. Virtual functions, function overloading vs function overriding, usage of virtual functions, examples, pure virtual functions, virtual destructors, exception handling.

## 1. Виртуальные функции (Virtual Functions)

### 1.1 Определение виртуальной функции

> **Виртуальная функция** в C++ — это функция, объявленная в базовом классе с ключевым словом `virtual`, которая может быть _переопределена_ (overridden) в производном классе.

> **Главная особенность**: при вызове такой функции через _указатель или ссылку_ на базовый класс, но фактически указывающий на объект производного класса, будет вызвана _реальная_ (переопределённая) функция из производного класса.

Это механизм _динамического полиморфизма_ (runtime polymorphism): решение о том, какая реализация функции вызывается, происходит во _время выполнения_, а не на этапе компиляции.

### Пример

```cpp
class Base
{
public:
    // Виртуальная функция.
    virtual void display()
    {
        std::cout << "Base class\n";
    }
};

class Derived : public Base
{
public:
    // Переопределение виртуальной функции.
    void display()
    {
        std::cout << "Derived class\n";
    }
};

int main()
{
    Derived derivedObj;
    Base* basePtr = &derivedObj; // Или basePtr = new Derived;
    basePtr->display(); // Выведет: "Derived class".

    Base& baseRef = derivedObj;
    baseRef.display(); // Выведет: "Derived class".

    Base baseObj = derivedObj;
    baseObj.display(); // Выведет: "Base class", так как baseObj не указатель и не ссылка на объект класса наследника.
}
```

Если бы `display()` не была объявлена `virtual` в классе `Base`, то вызовы `basePtr->display()` и `baseRef.display()` _всегда_ вызывали бы метод `Base::display()`, несмотря на то, что `basePtr` указывает на объект `Derived`.

### 1.2 Ключевое слово `override`

Начиная с C++11, при переопределении виртуальной функции в производном классе рекомендуется использовать ключевое слово `override`. Оно указывает компилятору, что метод действительно должен переопределять виртуальную функцию из базового класса. Если в базовом классе не было подходящей виртуальной функции с такой же сигнатурой, произойдёт ошибка компиляции (что помогает избежать опечаток и скрытых ошибок).

```cpp
class Base
{
public:
    // Виртуальная функция.
    virtual void display()
    {
        std::cout << "Base class\n";
    }
};

class Derived : public Base
{
public:
    void display() override // override даёт дополнительную проверку от компилятора
    {
        std::cout << "Derived class\n";
    }
};
```

`override` нужен для двух вещей:

1. Чтобы человек, который читает код, знал бы, что данная функция является переопределением функции базового класса.
2. Если вдруг человек, который пишет код, неправильно напишет декларацию функции, но напишет рядом `override`, то код не скомпилируется и компилятор укажет, что переопределение функции сделано неверно (Это лучше чем если бы код скомпилировался бы и дальше искали бы логическую ошибку)

### 1.3 Виртуальность наследуется

Мы объявлил функцию `Base::display` виртуальной, но не объявили `Derived::display` виртуальной. Не смотря на это - `Derived::display` также виртуальная функция, то есть если наследоваться от `Derived` как в нижеприведенном примере

```cpp
class Derived : public Base
{
public:
    void display()
    {
        std::cout << "Derived class\n";
    }
};

class MoreDerived : public Derived
{
public:
    void display()
    {
        std::cout << "MoreDerived class\n";
    }
};

int main()
{
    Derived* ptr = new MoreDerived();
    ptr->display();
    delete ptr;
}
```
Тогда `ptr->display();` вызовет функцию `MoreDerived::display` не смотря на то, что `display` не объявляна виртуальной в классе `Derived`. Всё из-за того, что `Derived` является виртуальной в классе `Base`. Таким образом мы нашли

> ***ОЧЕНЬ ВАЖНОЕ ПРАВИЛО:*** Виртуальность наследуется.

### 1.4 Поведение виртуальных функций при аргументах с дефолтным значением

Если виртуальная функция в базовом классе принимает аргумент с дефолтным значением, а в классе наследнике принимает аргумент с другим дефолтным значением, то при вызове данной виртуальной функции с указателя или ссылки типа родителя на объект наследника вызовется функция наследника, но будет учитываться дефолтное значение в родителе.

После такого сложного предложения рассмотрим легкий пример, на котором можно понять о чем идет речь.

```cpp
struct A
{
    virtual void f(int x=5) 
    {
        std::cout << "Base: "<< x;
    }
};

struct B : A
{
    void f(int x=6) override
    {
        std::cout << "Derived: " << x;
    }
};

int main()
{
    A* ptr = new B;
    ptr->f();
    delete ptr;
}
```

Как уже было сказано выражение `ptr->f();` вызовет функцию наследника `B::f`, но программа напечатает 
```cpp
"Derived: 5"
```
Все из-за того, что дефолтное значение переменной `x` задается во время компиляции. Компилятор смотрит в выражении `ptr->f();` какой тип у `ptr` и видит, что `A*`, а следовательно функции `f` будет передано дефолтное значение функции `A::f`. Уже на рантайме, когда будет исполнятся строка `ptr->f();` будет учтено на что именно указывает `ptr`, а он указывает на объект `B`, таким образом будет вызвана `B::f` и передано будет значение `x=5`.

## 2. Перегрузка функций (Function Overloading) vs Переопределение функций (Function Overriding)

### 2.1 Перегрузка функций (Function Overloading)

> **Определение**: Перегрузка — это механизм, при котором в _одном и том же классе_ (или в одной области видимости) можно объявить несколько функций с одним именем, _но разным списком параметров_ (типы, количество, порядок).

- **Когда происходит выбор**: Во _время компиляции_ (compile-time).
- **Цель**: Удобство использования одного и того же «имени операции», но с разными типами данных.

#### Пример

```cpp
void print(int i) {
    std::cout << "Integer: " << i << std::endl;
}

void print(double d) {
    std::cout << "Double: " << d << std::endl;
}

void print(std::string s) {
    std::cout << "String: " << s << std::endl;
}

```

Здесь три функции `print`, которые отличаются набором параметров. Компилятор по типу аргументов в момент вызова решает, какую функцию вызвать.

#### Особенности перегрузки

- Параметры должны различаться по **типам**, **количеству** или **порядку**.
- Возвращаемый тип **не** участвует в выборе перегруженной функции.
- Это **статический полиморфизм** (compile-time polymorphism).

## 2.2 Переопределение функций (Function Overriding)

> **Определение**: Переопределение (overriding) — это механизм, при котором _производный класс_ предоставляет _новую реализацию_ виртуальной функции, объявленной в _базовом классе_.

- **Когда происходит выбор**: Во _время выполнения_ (runtime), если вызов идёт через указатель/ссылку на базовый класс. (`Base* basePtr = new Derived(); basePtr->display()`)
- **Цель**: Реализовать полиморфизм; предоставить уникальное поведение для разных типов, имеющих общий интерфейс.

[Пример]

```cpp
class Base {
public:
    virtual void show() {
        std::cout << "Base show\n";
    }
};

class Derived : public Base {
public:
    void show() override {
        std::cout << "Derived show\n";
    }
};

```

#### Отличие от перегрузки

- **Перегрузка** (overloading) — несколько функций **в одном классе** с одним именем, но **разными параметрами** (compile-time).
- **Переопределение** (overriding) — функции с одинаковым названием и аргументами в базовом и производном классе, с ключевым словом `virtual` в базовом классе (runtime). Желательно также писать `override` справа от декларации функции в производном классе.

## 3. Использование виртуальных функций

### Виртуальные функции применяются:

1. _Для организации общего интерфейса_ в базовом классе, с разными реализациями в производных классах.
2. _Для хранения и обработки объектов разнородных типов_ (но с общей базой) в _контейнерах_, используя динамический полиморфизм.

### Небольшой пример с «животными», где у каждого животного свой звук

```cpp
class Animal {
public:
    virtual void sound() {
        std::cout << "Some generic animal sound\n";
    }

    virtual ~Animal() = default; // виртуальный деструктор
};

class Dog : public Animal {
public:
    void sound() override {
        std::cout << "Woof!\n";
    }
};

class Cat : public Animal {
public:
    void sound() override {
        std::cout << "Meow!\n";
    }
};

int main() {
    Animal* a1 = new Dog();
    Animal* a2 = new Cat();

    a1->sound(); // Woof!
    a2->sound(); // Meow!

    delete a1;
    delete a2;
    return 0;
}

```

Если бы не было виртуальной функции, всегда вызывался бы метод `Animal::sound()`.

## 4. Чисто виртуальные функции (Pure Virtual Functions)

> ***ОПРЕДЕЛЕНИЕ:*** Чисто виртуальная функция - это виртуальная функция, после декларации которой написали = 0

Синтаксис:
`virtual <returnType> <functionName>(<arguments>) = 0;`

> ***ОПРЕДЕЛЕНИЕ:*** Класс, содержащий хотя бы одну чисто виртуальную функцию, называется **абстрактным классом** (abstract class).

> ***Главное свойство абстрактного класса:*** Нельзя создавать объект абстрактного класса. Если попытаться - будет ошибка компиляции.


### Пример

```cpp
class Shape
{
public:
    virtual void draw() = 0; // чисто виртуальная функция
};

class Circle : public Shape
{
public:
    void draw() override
    {
        std::cout << "Drawing Circle\n";
    }
};

class Square : public Shape
{
public:
    void draw() override
    {
        std::cout << "Drawing Square\n";
    }
};

int main()
{
    // Shape s; // Ошибка: класс Shape — абстрактный, нельзя создавать объекты
    Shape* c = new Circle();
    Shape* sq = new Square();

    c->draw();   // Drawing Circle
    sq->draw();  // Drawing Square

    delete c;
    delete sq;
    return 0;
}

```
Класс `Shape` является абстрактным, так как содержит одну чисто-виртуальную функцию. Если бы мы попытались создать объект класса `Shape`, не важно каким способом, получили бы ошибку компиляции. А именно

```cpp
Shape obj; // Ошибка компиляции.
Shape* basePtr = new Shape(); // Ошибка компиляции.
Shape* ptr = new Circle(); // Не возникнет никакой ошибки, так как не создаётся объект класса `Shape`. Тут лишь создается объект класса `Circle` а он не является абстрактным, так как он переопределил метод `draw`.
```

> ***ОЧЕНЬ ВАЖНОЕ ПРАВИЛО 1:*** Чистая виртуальность функции наследуется, если не переопределять эту функцию в наследнике.

> ***ОЧЕНЬ ВАЖНОЕ ПРАВИЛО 2:*** Абстрактность наследуется, если не переопределять все чисто виртуальные функции базового класса.

Таким образом, если бы мы не переопределили метод `draw()` в классах `Circle` и `Square`, то эти классы также являлись бы абстрактными и нельзя было бы создать их объекты, что привело бы к ошибке конпиляции на строках

```cpp
    Shape* c = new Circle();
    Shape* sq = new Square();
```

> ***Замечание:*** У любой чисто виртуальной функции может быть тело (хотя это и не обязательно). Смотри пример чисто виртуального деструктора.

## 5. Виртуальные деструкторы (Virtual Destructors)

### Зачем нужны?

Если класс содержит хотя бы одну виртуальную функцию (или предполагается использовать полиморфизм), **настойчиво рекомендуется** объявлять деструктор виртуальным. Иначе при удалении объекта производного класса через указатель базового типа может не вызваться деструктор производного класса, что часто приводит к утечкам ресурсов.

#### Пример

```cpp
#include <iostream>

class Base
{
public:
    virtual ~Base()
    {
        std::cout << "Base destructor\n";
    }
};

class Derived : public Base
{
public:
    ~Derived() override
    {
        std::cout << "Derived destructor\n";
    }
};

int main()
{
    Base* obj = new Derived();
    delete obj;  // сначала ~Derived(), потом ~Base()
    return 0;
}

```

### Чисто виртуальный деструктор

Иногда делают и деструктор чисто виртуальным:

```cpp
class AbstractBase
{
public:
    virtual ~AbstractBase() = 0; // объявляем как чисто виртуальный
};

inline AbstractBase::~AbstractBase()
{
    // даже для чисто виртуального деструктора нужно тело.
}

```

Зачем? Чтобы класс нельзя было инстанциировать, но при этом чтобы деструктор оставался виртуальным (для корректного удаления объектов производных классов).



Вывод:
`Derived destructor Base destructor`

Если убрать `virtual` у деструктора `Base`, то при `delete obj` вызвался бы _только_ `~Base()`, а `~Derived()` — _нет_, что привело бы к утечкам или некорректному освобождению.

## 6. Обработка исключений (Exception Handling)

> **Исключения** — это механизм языка, позволяющий «выбрасывать» (throw) и «ловить» (catch) ошибки, которые могут возникнуть в программе. В С++ он позволяет отделить _логику обработки ошибок_ от _основного потока кода_.

**Синтаксис:**

```cpp
try {
    // Блок кода, где может произойти ошибка
    // ...
    throw std::runtime_error("Some error"); 
} 
catch (const std::exception& e) {
    // Блок, который перехватывает исключения типа std::exception и его наследников
    std::cerr << "Exception: " << e.what() << std::endl;
}
catch (...) {
    // "Поймать всё" — ловит исключения любого типа
    std::cerr << "Unknown exception caught!\n";
}

```

#### Пример

```cpp
#include <iostream>
#include <stdexcept>

int divide(int a, int b)
{
    if (b == 0)
    {
        throw std::runtime_error("Division by zero");
    }
    return a / b;
}

int main()
{
    try
    {
        std::cout << divide(10, 2) << std::endl;  // 5
        std::cout << divide(10, 0) << std::endl;  // исключение!
    }
    catch (const std::exception& e)
    {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}

```

- При вызове `divide(10, 0)` генерируется исключение `std::runtime_error`, которое перехватывается блоком `catch (const std::exception& e)`.
- `what()` — это метод, определённый в классе `std::exception` (и его производных) в C++. Он используется для получения текста сообщения об исключении в виде строки.

### Дополнительные моменты

- **Стек раскручивается** (stack unwinding) — объекты локальных переменных уничтожаются по пути выхода из функции, где возникло исключение.
- Можно объявлять и _свои_ классы исключений, например, наследуясь от `std::exception`.
- Ключевое слово `noexcept` в современном C++ указывает, что функция _не_ будет выбрасывать исключения. При нарушении этого обещания программа обычно завершается (`std::terminate).
- В _конструкторах_ исключения разрешены, но нужно аккуратно продумать последствия. В _деструкторах_ бросать исключения крайне не рекомендуется (если при разрушении объекта выбросится исключение, а одновременно выбросится ещё одно исключение из другого деструктора, это приведёт к `std::terminate()`).

### Итоги

1. **Виртуальные функции** — это ключевой механизм _динамического полиморфизма_. Они позволяют определять, какая версия функции (базовая или производная) должна быть вызвана _во время выполнения_.
2. **Перегрузка (overloading)** и **переопределение (overriding)** — это разные понятия:
   - **Перегрузка**: несколько функций _в одном классе_ с одним именем и _разными параметрами_ (compile-time).
   - **Переопределение**: новая реализация виртуальной функции _в производном классе_ (runtime).
3. **Чисто виртуальные функции** превращают класс в _абстрактный_, заставляя производные классы предоставлять собственную реализацию.
4. **Виртуальный деструктор** необходим для корректного удаления объектов производных классов через указатель на базовый класс (избежание утечек и некорректного освобождения).
5. **Обработка исключений** даёт возможность отделять логику работы с ошибками от основной логики программы и обеспечивает корректное освобождение ресурсов при возникновении ошибок.

# OOP Concepts

## 1. **Encapsulation**:
*(если спросят на интервью)*
Это возможность модифицировать доступ к свойствам ваших классов. В C++ через `public`, `private` и `protected`.

*(исходное определение)*
Инкапсуляция позволяет хранить данные и функции, которые работают с этими данными в одной структуре, которая называется классом.

## 2. **Inheritance**:
Это передача свойств одного класса другому.

*пример*:
```cpp
class Base {
public:
	int x;
};

class Derived : public Base {
public:
	void show() { std::cout << x; }
};
```

## 3. **Polymorphism**:
*(в языке)*
Это когда две отдельные сущности имеют одно и то же имя.
*нпр*: hot (горячо/остро)

*(в с++)*
Полиморфизм разделяется на два типа:

° **статичный**: происходит compile time
*нпр*: перегрузка функций, шаблоны

° **динамичный**: runtime решается какая из функций с одинаковым именем вызывается. Динамический полиморфизм в C++ происходит с помощью виртуальных функций.

*нпр*:
```cpp
class Base {
public:
	virtual void print() 
    {
        std::cout << "Base";
        }
};
class Derived : public Base
{
	public:void print() override
    {
        std::cout << "Derived"; 
    }
};
```

## 4. **Abstraction:**
Это рассмотрение тех свойств субъекта, которые важны при решении задачи, и отбрасывание остальных свойств. В C++ абстракция реализуется через чисто виртуальные функции и абстрактные классы.

*Пример абстракции*:
Вы пользуетесь телефоном, зная его функционал (звонки, камера), знаете номер телефона Саши, но не думаете о том, как телефон устроен внутри.

```cpp
struct AbstractPhone
{
    virtual void call(unsigned long long number) = 0;
}

void callSash(AbstractPhone* phone, unsigned long long sashsNumber)
{
    phone->call(sashsNumber);
}
```

Когда мы написали функцию `callSash` мы в принципе не знали как именно работает телефон и как имплементирована фунцкия `call`, нам в принципе в данный момент это не важно, но когда мы переопределим функцию `call` в классе наследнике мы все еще сможем пользоваться функцией `callSash` и не придется писать ее заново.

```cpp
struct MangustPhone : AbstractPhone
{
    void call(unsigned long long number) override
    {
        // The implementation of the call function for a Samsung phone.
    }
}

int main()
{
    MangustPhone* mangust = new MangustPhone();
    callSash(mangust, 94271927);
    delete mangust;
}
```